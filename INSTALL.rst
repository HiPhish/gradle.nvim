.. default-role:: code

########################
 Installing Gradle.nvim
########################

Installing Gradle.nvim is a two-step process: first you need to install it like
any other Neovim plugin, then you need to build the Java remote plugin. I will
assume that you are familiar with how to install Neovim plugins, and only focus
on building it from now on. There is a variety of Neovim plugin managers which
can automatically download the package and execute the shell commands for
building the Java application.

You will need the following dependencies installed, and I will assume you know
how to use them generally:

- Gradle_ (tested with version 6.0+)
- JDK_ 11+ (any distribution should work)

You need the JDK to run Java applications, and you need Gradle in order to
download the Gradle wrapper, which will then be used to actually build the
application. Most projects include the Gradle wrapper in their VCS repository,
but after considering the arguments I have decided against doing so. My
rationale is explained further below. In the future there might be distribution
releases which do include the wrapper.


Building the application
########################

First download the Gradle wrapper. The build script ensures that the correction
version of the wrapper is downloaded, so your installed Gradle version should
not matter.

.. code-block:: sh

   gradle wrapper

Then build the application using the wrapper.

.. code-block:: sh

   # On Unix
   ./gradlew install

   # On Microsoft Windows
   gradlew.bat install


Against version-controlling the Gradle wrapper
##############################################

The officially recommended way is to include the Gradle wrapper in the VCS
repository of the project. The argument for this is that it allows users to
build the project without having to install Gradle, and that it ensures that
all users have the right version of Gradle to build with. Here I aim to explain
my rationale for going against the official advice.

We can group the files in a project roughly into two categories: sources and
build products. Sources are what the authors have intentionally created, and
build products are created during the build from the source. Often times the
distinction is obvious, but sometimes the lines can get blurry. For example, a
binary executable build from source code is definitely a build product, but
what about source code generated by a tool like yacc_?

My rule of thumb is that anything which cannot be created by a machine is
source. Even a binary file like an image can be source, but only if the image
had to be put together by a human. If the image was generated or assembled from
other images it is a build product. Source code generated from a tool is a
build product, while the specification file it was generated from is a source.
Some sources might have been *initially* generated by a tool, but they are
*intended* to be edited by a human.

This brings us to the Gradle wrapper. The wrapper is not intended to be edited
by a human. It will remain constant and only occasionally replaced by a newer
wrapper, which is also generated. This makes it either a build target or a
dependency.

So what about the convenience arguments? I do not believe that they hold much
merit. The wrapper version can easily be fixed by declaring it in the
`build.gradle` file. This will ensure that every user can use the correct
Gradle version for building, regardless of which version of Gradle they might
have installed on their system. Which brings us to the other point: requiring
Gradle to be install on a developer's system is not an unrealistic requirement.
It can be installed easily through a variety of package managers, or even
manually. After all, why stop at Gradle? Why not also include the JVM in the
repository as well?

There is one case where including the wrapper is justified though: when
providing source distributions to end-users. This is the approach taken for
example by the `GNU Autotools`_; the development repository contains only the
specifications for building the `configure` script. When a distribution tarball
is created the `configure.ac` file is used to create the `configure` script
which is then included in the tarball. That way end users can build the
software which needing to have the Autotools installed.

There is little use for source distribution in the Java world though, since the
binaries run on the JVM. I might add source distributions in the future when
the project becomes more mature.


.. ----------------------------------------------------------------------------
.. _Gradle: https://gradle.org/
.. _JDK: https://jdk.java.net/
.. _yacc: https://en.wikipedia.org/wiki/Yacc
.. _GNU Autotools: https://en.wikipedia.org/wiki/GNU_Autotools
